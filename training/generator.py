"""
Code Generator Module
Generates Python code from learned patterns.
"""

import json

from config import get_testcases_path

import json


def generate_trained_patterns_code():
    """
    Generate the trained_patterns.py file content.
    
    Returns:
        String containing the generated Python code
    """
    return '''# Trained patterns from testcases.json
# Generated by training.py
# Comprehensive patterns database for meeting extraction

from datetime import datetime as dt, timedelta, timezone
from dateutil.parser import parse as date_parse
import re
import uuid
import sys
import os

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import from modules - fallback to inline definitions if modules not available
try:
    from modules.date_utils import extract_date
    from modules.time_utils import extract_time
    from modules.meeting_extractor import find_email_by_name
    
    def resolve_datetime_from_text(text, base_dt=None, allow_past=False, skip_past_check=False):
        """Fallback resolve_datetime using separate date/time extraction."""
        from datetime import datetime, timezone, timedelta
        
        if base_dt is None:
            base_dt = datetime.now(timezone(timedelta(hours=5, minutes=30)))
        
        extracted_date, is_past = extract_date(text, base_dt=base_dt)
        extracted_time = extract_time(text)
        
        if extracted_date and extracted_time:
            return extracted_date.replace(hour=extracted_time.hour, minute=extracted_time.minute, second=0, microsecond=0)
        elif extracted_date:
            return extracted_date.replace(hour=14, minute=0, second=0, microsecond=0)
        return base_dt
except ImportError:
    def find_email_by_name(name):
        name_email_map = {
            'john': 'john@example.com', 'jane': 'jane@example.com',
            'priya': 'priya@example.com', 'rahul': 'rahul@example.com',
            'neha': 'neha@example.com', 'karthik': 'karthik@example.com',
        }
        name_lower = name.lower().strip()
        for key, email in name_email_map.items():
            if key in name_lower or name_lower in key:
                return email
        return name.lower().replace(' ', '.') + '@example.com'
    
    def resolve_datetime_from_text(text, base_dt=None):
        from datetime import datetime as dt, timedelta, timezone
        import re
        if base_dt is None:
            base_dt = dt.now()
        text_lower = text.lower()
        now = base_dt
        
        # Handle date formats
        dd_mm_yyyy_match = re.search(r'(\d{2})[-/](\d{2})[-/](\d{4})', text_lower)
        if dd_mm_yyyy_match:
            day = int(dd_mm_yyyy_match.group(1))
            month = int(dd_mm_yyyy_match.group(2))
            year = int(dd_mm_yyyy_match.group(3))
            target_date = dt(year, month, day)
            
            time_match = re.search(r'(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)', text_lower, re.IGNORECASE)
            if time_match:
                hour = int(time_match.group(1))
                minute = int(time_match.group(2)) if time_match.group(2) else 0
                ampm = time_match.group(3)
                if ampm == 'pm' and hour != 12:
                    hour += 12
                elif ampm == 'am' and hour == 12:
                    hour = 0
                target_date = target_date.replace(hour=hour, minute=minute, second=0, microsecond=0)
            else:
                target_date = target_date.replace(hour=17, minute=0)
            return target_date
        
        return (now + timedelta(days=1)).replace(hour=18, minute=0)


# ============================================================================
# PATTERNS
# ============================================================================

ACTION_TO_INTENT = {
    'schedule_meeting': ['schedule', 'set up', 'book', 'fix', 'arrange', 'create', 'plan', 'block'],
    'reschedule_meeting': ['reschedule', 'move', 'shift', 'push', 'postpone'],
    'cancel_meeting': ['cancel', 'delete', 'remove'],
    'update_meeting': ['update', 'change', 'modify', 'replace'],
}

MEET_LINK_PATTERN = r'(https?://)?(meet\.google\.com/|[a-z]{2,3}-meet\.google\.com/)[a-zA-Z0-9_-]+'

OFFLINE_PATTERNS = [
    r'\bin\s*boardroom\b', r'\bat\s*boardroom\b', r'\bboardroom\b',
    r'\bin\s*office\b', r'\bin\s*the\s*office\b',
    r'\bin\s*cabin\b', r'\bin\s*cafeteria\b', r'\bin\s*pantry\b',
    r'\bin\s*conference\b', r'\bconference\s*room\b',
    r'\bin-person\b', r'\bface-to-face\b',
]

ONLINE_PATTERNS = [
    r'\bgmeet\b', r'\bgoogle\s*meet\b', r'\bzoom\b',
    r'\bonline\b', r'\bvirtual\b',
]

DURATION_PATTERNS = [
    (r'\b(\d+)\s*(?:hour|hr|hrs)\b', 60),
    (r'\b(\d+)\s*(?:min|minute|mins)\b', 1),
    (r'\bhalf\s*hour\b', 30),
    (r'\bquick\b', 15),
    (r'\bbrief\b', 15),
]

AGENDA_PATTERNS = [
    (r'\babout\s+([a-zA-Z][a-zA-Z\s]+?)(?:,|\.|$)', 1),
    (r'\bfor\s+([a-zA-Z][a-zA-Z\s]+?)(?:,|\.|$)', 1),
]

ATTENDEE_PATTERNS = [
    (r'\bwith\s+([A-Z][a-z]+(?:\s*,\s*[A-Z][a-z]+)*)\b', 1),
    (r'\bwith\s+([A-Z][a-z]+\s+(?:and|&)\s+[A-Z][a-z]+)\b', 1),
    (r'\bfor\s+([A-Z][a-z]+)\b', 1),
]

TIME_MODIFIERS = [
    (r'\bby\s+(\d+)\s*(min|minute|minutes)\b', 1),
    (r'\bby\s+(\d+)\s*(hour|hr|hours)\b', 60),
]


# ============================================================================
# EXTRACTION FUNCTION
# ============================================================================

def extract_explicit_end_time(sentence, start_dt):
    """Extract explicit end time from patterns like '5pm to 7pm', 'till 9', etc."""
    match = re.search(
        r'\b(?:to|till|until)\s*(?![-/])(\d{1,2})(?::(\d{2}))?\s*(am|pm)?\b',
        sentence,
        re.IGNORECASE
    )
    
    if not match:
        return None
    
    hour = int(match.group(1))
    minute = int(match.group(2) or 0)
    ampm = match.group(3)
    
    if ampm:
        if ampm.lower() == "pm" and hour < 12:
            hour += 12
        elif ampm.lower() == "am" and hour == 12:
            hour = 0
    else:
        if start_dt.hour >= 12 and hour < 12:
            hour += 12
    
    end_dt = start_dt.replace(hour=hour, minute=minute, second=0, microsecond=0)
    
    if end_dt <= start_dt:
        end_dt += timedelta(days=1)
    
    return end_dt


def extract_meeting_details_trained(sentence):
    """Extract meeting details using trained patterns."""
    text = sentence.lower().strip()
    now = dt.now()
    
    details = {
        "action": "create", "intent": "schedule_meeting",
        "attendees": [], "attendee_names": [], "datetime_text": "",
        "duration_min": 30, "mode": "online", "location": "",
        "link_preference": "auto_generate_meet", "agenda": "",
        "meeting_title": "", "constraints": [], "time_window": None,
        "recurrence": [], "start": None, "end": None,
        "description": "", "requestId": str(uuid.uuid4()),
        "reminders": {"useDefault": False, "overrides": [{"method": "popup", "minutes": 10}]}
    }
    
    # Action Detection
    if re.search(r'\b(reschedule|move|shift|push|postpone)\b', text):
        details["action"] = "reschedule"
        details["intent"] = "reschedule_meeting"
        for pattern, mult in TIME_MODIFIERS:
            if re.search(pattern, text):
                mod_match = re.search(pattern, text)
                if mod_match:
                    val = int(mod_match.group(1))
                    details["constraints"].append(f"modify_time_by:{val}")
                break
    elif re.search(r'\b(cancel|delete|remove)\b', text):
        details["action"] = "cancel"
        details["intent"] = "cancel_meeting"
    elif re.search(r'\b(update|change|modify|replace|switch)\b', text):
        details["action"] = "update"
        details["intent"] = "update_meeting"
    
    # Mode and Location
    for pattern in ONLINE_PATTERNS:
        if re.search(pattern, text):
            details["mode"] = "online"
            details["location"] = "Online"
            if re.search(r'\busual\b', text):
                details["link_preference"] = "use_usual_gmeet_link"
            break
    
    meet_link_match = re.search(MEET_LINK_PATTERN, sentence, re.IGNORECASE)
    if meet_link_match:
        details["mode"] = "online"
        details["location"] = "Online"
        details["use_meet"] = True
        details["link_preference"] = "use_provided_link"
        meet_link = meet_link_match.group(0)
        if not meet_link.startswith('http'):
            meet_link = 'https://' + meet_link
        details["meet_link"] = meet_link
    else:
        for pattern in OFFLINE_PATTERNS:
            if re.search(pattern, text):
                details["mode"] = "offline"
                if re.search(r'\bboardroom\b', text):
                    details["location"] = "Boardroom"
                elif re.search(r'\bconference\s*room\s*([a-z]+)\b', text):
                    m = re.search(r'\bconference\s*room\s*([a-z]+)\b', text)
                    details["location"] = f"Conference Room {m.group(1).upper()}"
                elif re.search(r'\bcabin\b', text):
                    details["location"] = "Cabin"
                elif re.search(r'\bcafeteria\b', text):
                    details["location"] = "Cafeteria"
                elif re.search(r'\bpantry\b', text):
                    details["location"] = "Pantry"
                break
    
    # Attendee Extraction
    person_names = []
    for pattern, group_idx in ATTENDEE_PATTERNS:
        match = re.search(pattern, sentence, re.IGNORECASE)
        if match and match.lastindex and match.lastindex >= group_idx:
            name_part = match.group(group_idx)
            if name_part:
                name_part = name_part.strip()
                if name_part.lower() not in ['the', 'a', 'an']:
                    if ' and ' in name_part.lower() or ' & ' in name_part:
                        names = re.split(r"\s+(?:and|&)\s+", name_part, flags=re.IGNORECASE)
                        for name in names:
                            name = name.strip()
                            if name and len(name) > 1:
                                person_names.append(name.title())
                    else:
                        person_names.append(name_part.title())
                break
    
    attendees_emails = []
    for person_name in person_names:
        email = find_email_by_name(person_name)
        if email:
            attendees_emails.append({"email": email})
        else:
            fallback = person_name.lower().replace(" ", ".") + "@example.com"
            if {"email": fallback} not in attendees_emails:
                attendees_emails.append({"email": fallback})
    
    details["attendees"] = attendees_emails
    details["attendee_names"] = person_names
    
    # Datetime
    start_dt = resolve_datetime_from_text(sentence, now)
    if start_dt.tzinfo is None:
        start_dt = start_dt.replace(tzinfo=timezone(timedelta(hours=5, minutes=30)))
    
    # Duration
    duration = 30
    explicit_end = extract_explicit_end_time(sentence, start_dt)
    
    if explicit_end:
        duration = int((explicit_end - start_dt).total_seconds() / 60)
        end_dt = explicit_end
    else:
        for pattern, mult in DURATION_PATTERNS:
            if re.search(pattern, text):
                dur_match = re.search(pattern, text)
                if dur_match:
                    val = int(dur_match.group(1))
                    if 'hour' in dur_match.group(0):
                        val *= 60
                    duration = val
                break
        end_dt = start_dt + timedelta(minutes=duration)
    
    if re.search(r'\b(quick|brief|short)\b', text):
        duration = 15
        end_dt = start_dt + timedelta(minutes=15)
    
    if details["action"] == "reschedule":
        for c in details["constraints"]:
            if "modify_time_by" in c:
                mod_val = int(c.split(":")[1])
                start_dt = start_dt + timedelta(minutes=mod_val)
                if explicit_end:
                    duration = int((end_dt - start_dt).total_seconds() / 60)
                else:
                    end_dt = start_dt + timedelta(minutes=duration)
                break
    
    details["start"] = start_dt
    details["end"] = end_dt
    details["duration_min"] = duration
    
    # Agenda
    agenda = ""
    for pattern, group_idx in AGENDA_PATTERNS:
        match = re.search(pattern, text)
        if match and match.lastindex and match.lastindex >= group_idx:
            agenda = match.group(group_idx)
            break
    
    if not agenda:
        meeting_type_match = re.search(r"\b(standup|sync|demo|call|discussion|review|planning)\b", text)
        if meeting_type_match:
            agenda = meeting_type_match.group(1).title()
        else:
            agenda = "Meeting"
    
    details["agenda"] = agenda
    
    # Meeting Title
    if person_names:
        if len(person_names) == 1:
            attendee_str = f"with {person_names[0]}"
        else:
            attendee_str = f"{', '.join(person_names[:-1])} and {person_names[-1]}"
    else:
        attendee_str = ""
    
    meeting_type_match = re.search(r"\b(meeting|call|sync|demo|standup|review)\b", text)
    meeting_type = meeting_type_match.group(1).title() if meeting_type_match else "Meeting"
    
    days = ["monday", "tuesday", "wednesday", "thursday", "friday"]
    day = days[start_dt.weekday()].title() if start_dt else ""
    time_str = start_dt.strftime("%#I:%M %p") if start_dt else ""
    
    if agenda.lower() == meeting_type.lower():
        meeting_type = ""
    
    if attendee_str and day and time_str:
        title = f"{agenda} {meeting_type} {attendee_str} on {day} at {time_str}".strip()
    elif attendee_str:
        title = f"{agenda} {meeting_type} {attendee_str}".strip()
    elif day and time_str:
        title = f"{agenda} {meeting_type} on {day} at {time_str}".strip()
    else:
        title = f"{agenda} {meeting_type}".strip()
    
    title = " ".join(title.split())
    details["meeting_title"] = title
    
    # Description
    date_time = start_dt.strftime("%A at %I:%M %p") if start_dt else "TBD"
    purpose = agenda
    
    if details["mode"] == "online":
        link = "Google Meet (usual link)" if details["link_preference"] == "use_usual_gmeet_link" else "Google Meet"
        location_display = link
        physical_address = "N/A (Online)"
    else:
        location_display = "In-person"
        physical_address = details.get("location", "Not specified")
    
    details["description"] = (
        f"Date & Time: {date_time}\\n"
        f"Purpose: {purpose}\\n"
        f"Location: {location_display}\\n"
        f"Physical Address: {physical_address}"
    )
    
    return details


if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        result = extract_meeting_details_trained(sys.argv[1])
        print(json.dumps(result, indent=2, default=str))
    else:
        print("Usage: python trained_patterns.py \\"Your request\\"")
'''


def save_generated_code(code, filename='trained_patterns.py'):
    """Save generated code to file."""
    with open(filename, 'w') as f:
        f.write(code)
    print(f"Generated code saved to {filename}")


def generate_and_save():
    """Generate code and save to file."""
    code = generate_trained_patterns_code()
    save_generated_code(code)
    return code


if __name__ == "__main__":
    generate_and_save()
